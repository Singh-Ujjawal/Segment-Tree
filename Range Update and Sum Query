class SegmentTree {
   public:
   vector<int> seg;
   vector<int> lazy;
   int n;
   SegmentTree(int n) {
      this->n = n;
      seg.resize(n*4);
      lazy.resize(n*4,0);
   }
   
   void buildTree(int ind,int start,int end,vector<int> &arr) {
      if(start==end) {
         seg[ind] = arr[start];
         return ;
      }
      int mid = start + (end-start)/2;
      buildTree(2*ind+1,start,mid,arr);
      buildTree(2*ind+2,mid+1,end,arr);
      seg[ind] = seg[2*ind+1]+seg[2*ind+2];
   }

   int get(int ind,int start,int end,int leftRange,int rightRange) {
      if(start>rightRange or end<leftRange) return 0;
      if(leftRange<=start and end<=rightRange) return seg[ind];
      int mid = start + (end-start)/2;
      int left = get(2*ind+1,start,mid,leftRange,rightRange);
      int right = get(2*ind+2,mid+1,end,leftRange,rightRange);
      return left + right;
   }

   void pointUpdate(int ind,int start,int end,int pointToUpdate,int valToUpdate) {
      if(start==end) {
         seg[ind] += valToUpdate;
         return ;
      }
      int mid = start + (end-start)/2;
      if(pointToUpdate>=start and pointToUpdate<=mid) {
         pointUpdate(2*ind+1,start,mid,pointToUpdate,valToUpdate);
         seg[ind] = seg[2*ind+1] + seg[2*ind+2];
      }
      else {
         pointUpdate(2*ind+2,mid+1,end,pointToUpdate,valToUpdate);
         seg[ind] = seg[2*ind+1] + seg[2*ind+2];
      }
   }

   void rangeUpdate(int ind,int start,int end,int leftRange,int rightRange,int valueToUpdate)  {
      if(lazy[ind]!=0) {
         seg[ind] += ((end-start)+1)*lazy[ind];
         if(start!=end) {
            lazy[2*ind+1] += lazy[ind];
            lazy[2*ind+2] += lazy[ind];
         }
         lazy[ind] = 0;
      }
      else if(start>rightRange or end<leftRange or start>end) return ;
      else if(start>=leftRange and end<=rightRange) {
         seg[ind] += ((end-start)+1)*valueToUpdate;
         if(start!=end) {
            lazy[2*ind+1] += valueToUpdate;
            lazy[2*ind+2] += valueToUpdate;
         }
         return ;
      }
      int mid = start + (end-start)/2;
      rangeUpdate(2*ind+1,start,mid,leftRange,rightRange,valueToUpdate);
      rangeUpdate(2*ind+2,mid+1,end,leftRange,rightRange,valueToUpdate);
      seg[ind] = seg[2*ind+1] + seg[2*ind+2];
   }

   int querySumLazy(int ind,int start,int end,int leftRange,int rightRange) {
      if(lazy[ind]!=0) {
         seg[ind] += ((end-start)+1)*lazy[ind];
         if(start!=end) {
            lazy[2*ind+1] += lazy[ind];
            lazy[2*ind+2] += lazy[ind];
         }
         lazy[ind] = 0;
      }
      if(start>rightRange or end<leftRange or start>end) return 0;
      else if(leftRange<=start and end<=rightRange) return seg[ind];
      int mid = start + (end-start)/2;
      int left = querySumLazy(2*ind+1,start,mid,leftRange,rightRange);
      int right = querySumLazy(2*ind+2,mid+1,end,leftRange,rightRange);
      return left + right;
   }
};
